# 复合类型

## 引用

引用是对现有对象的别名。定义引用后，对引用的任何操作都将应用于被引用的对象。



### 值类别

在C++中值分为左值(lvalue)和值(rvalue)



左值计算为可识别对象或函数的表达式（实体）

```C++
int main()
{
    int x { 5 };
    int y { x }; // x 是左值表达式

    return 0;
}
```



右值为非左值的表达式，右值表达式计算为一个值。

右值是不可识别的，并且仅存在于它们的表达式的范围内。

```C++
int return5()
{
    return 5;
}

int main()
{
    int x{ 5 }; // 5 是右值表达式
    const double d{ 1.2 }; // 1.2 是右值表达式

    int y { x }; // x 是可修改的左值表达式
    const double e { d }; // d 是不可修改的左值表达式
    int z { return5() }; // return5() 是右值表达式 expression (因为它的结果是按值返回)

    int w { x + 1 }; // x + 1 是右值表达式
    int q { static_cast<int>(d) }; // static_cast的结果是右值表达式

    return 0;
}
```



### 左值引用

引用是对象的别名。定义引用后，对引用的任何操作都将应用于被引用的对象。

可以使用引用来读取或修改被引用的对象。

* 所有左值引用必须在定义时初始化
* 左值引用必须绑定到可修改的左值
* 在大多数情况下，引用的类型必须与被引用的类型匹配
* 引用无法重置/更改为另一个对象



`&` 获取引用



使用左值引用变量

```cpp
#include <iostream>

int main()
{
    int x { 5 };    // x 是普通的int类型变量
    int& ref { x }; // ref 是int类型的左值引用变量，充当变量x的别名

    std::cout << x << '\n';  // 打印 x (5)
    std::cout << ref << '\n'; // 打印 x 通过 ref (5)

    return 0;
}
```

通过左值引用修改值

```C++
#include <iostream>

int main()
{
    int x { 5 }; // 普通int变量
    int& ref { x }; // ref 现在是 x 的别名

    std::cout << x << ref << '\n'; // 打印 55

    x = 6; // x 现在值是 6

    std::cout << x << ref << '\n'; // 打印 66

    ref = 7; // 对引用的对象（x）现在值是 7

    std::cout << x << ref << '\n'; // 打印 77

    return 0;
}
```



### const的左值引用

常量左值只能被常量左值引用所引用



```C++
int main()
{
    const int x { 5 };    // x 是不可修改的左值
    const int& ref { x }; // okay: ref 可以引用到x
	
    // 常量左值引用也无法被修改
    // ref = 10; error
    
    return 0;
}
```

常量左值引用可以引用可修改的对象，当常量左值引用依然无法被修改

### 作为函数参数使用

一般如下函数：

```cpp
int add(int x, int y) 
{
    return x + y;
}
```

该函数在传参时使用的是指传参，会将传入的实参拷贝至形参。

如果但参数为复杂对象时，会造成很大的使用成本。



#### 使用引用传参

使用引用传参将会传入实参地址，而不会拷贝新的实参

~~~cpp
#include <iostream>
#include <string>

void printValue(std::string& y) // 类型更改为 std::string&
{
    std::cout << y << '\n';
} // 变量y这里被销毁

int main()
{
    std::string x { "Hello, world!" };

    printValue(x); // x 现在按引用传递给参数 y (代价小)

    return 0;
}
~~~



通过引用也可以在函数中修改该实参的值

非引用：

```C++
#include <iostream>

void addOne(int y) // y 是 x 的拷贝
{
    ++y; // 修改的是 x 的拷贝, 而不是 x
}

int main()
{
    int x { 5 };

    std::cout << "value = " << x << '\n';

    addOne(x);

    std::cout << "value = " << x << '\n'; // x 未被修改

    return 0;
}
```

~~~cmd
value = 5
value = 5
~~~



使用引用：

```C++
#include <iostream>

void addOne(int& y) // y 被绑定到原始的 x
{
    ++y; // 修改的实际是 x
}

int main()
{
    int x { 5 };

    std::cout << "value = " << x << '\n';

    addOne(x);

    std::cout << "value = " << x << '\n'; // x 被修改了

    return 0;
}
```

~~~cmd
value = 5
value = 6
~~~



#### 使用常量引用传参

```C++
#include <iostream>

void printValue(const int& y) // y 是常量引用
{
    std::cout << y << '\n';
    y--; // error
}

int main()
{
    int x { 5 };
    printValue(x); // ok: x 是可修改的左值

    const int z { 5 };
    printValue(z); // ok: z 是不可修改的左值

    printValue(5); // ok: 5 是右值

    return 0;
}
```



## 指针